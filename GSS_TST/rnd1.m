function [fin] = rnd1(maxelem, rpt, interval)
% 
%   INPUTS:
%     maxelem  : элементы будут целыми числами от 1 до этого числа
%     rpt      : каждое число будет представлено в выборке столько раз
%     interval : минимальное число шагов, через которое в
%           последовательности может снова появиться тот же элемент
%     
%   OUTPUTS:
%     fin      : требуемая последовательность
%     

%% INI

ini = [];
fin = [];
count = 1:maxelem*rpt;

for i = 1:maxelem  % инициализируем исходную сумку
    ini = [ini;repmat(i,[rpt,1])];
end


pending = ini*0; % здесь будет хранится инфа о том, какие элементы брать нельзя


%% IMPL

while 1 % основной цикл
    ini0 = ini(pending==0); % "малая сумка" элементов, которые можно выбирать на данном шаге
    
    if isempty(ini0) % если малая сумка пуста, прекращаем все
        break
    end
    
    index = ceil(rand*numel(ini0)); % выбираем случайный индекс в малой сумке
    elem = ini0(index); % собственно элемент, лежащий под этим индексом
    fin = [fin, elem]; % добавляем его в ответ

    
    indexbig = count(ini==elem); % ищем в большой сумке такие элементы
    indexbig = indexbig(1); % берем из них первый попавшийся
    
    ini(indexbig) = []; % удаляем этот элемент из большой сумки
    pending(indexbig) = []; % удаляем соответствующую ему переменную задержки
    count(end) = []; % уменьшаем счетчик оставшихся элементов
    
    pending = floor(heaviside(pending - 1)); % уменьшаем всем элементам количество шагов ожидания на 1, но чтоб не меньше 0
    pending(ini==elem) = interval; % всем тэлементам, как тот, что только что выбрали, ставим ожидание, равное заданному интервалу
    
end

%% POST

cond = (numel(fin) ~= maxelem*rpt); % проверяем, остались ли элементы в большой сумке
if cond
    disp('Warning. Some numbers left in the bag'); % если да, говорим об этом
end

end

